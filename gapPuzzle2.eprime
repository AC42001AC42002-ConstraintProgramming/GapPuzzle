language ESSENCE' 1.0

$ @todo Prevent user from entering value greater than 7 (via a first contraint)?
$ @todo check "where"
$ @todo symmetry between horizontal axis and vertical axis? (and diagonal?)
$ @todo Don't forget to mention why we didn't go for extra padding in order to
$ solve the out-of-bound problem.

given length : int(1..)
given verticalGaps : matrix indexed by [int(1..length)] of int(1..)
given horizontalGaps : matrix indexed by [int(1..length)] of int(1..)

$ @todo Is it possible to find a list of points?
$ All filled squares indexed by x.
find xPoints : matrix indexed by [int(1..length), int(1..2)] of int(1..length)
$ All filled squares indexed by y.
find yPoints : matrix indexed by [int(1..length), int(1..2)] of int(1..length)

such that

forAll x : int(1..length) .
  forAll i : int(1..2) .
    yPoints[xPoints[x, i], i] = x,

$ All different points.
forAll point : int(1..length) .
  xPoints[point, 1] != xPoints[point, 2] /\
  yPoints[point, 1] != yPoints[point, 2],

$ No diagonal-touching.
forAll point : int(2..length - 1) .
  forAll i : int(-1, 1) .
    forAll k, l : int(1, 2) .
      (point > 1 -> xPoints[point - 1, k] != xPoints[point, l] + i)
      /\
      (point < length -> xPoints[point + 1, k] != xPoints[point, l] + i),

$ forAll y : int(1..length) .
$   (forAll xGap : int(y - horizontalGaps[y]..y + horizontalGaps[y]) .
$     ((xGap >= 1 /\ xGap <= length /\ xGap != y) -> (
$       xPoints[xGap, 1] != xGap /\
$       xPoints[xGap, 2] != xGap))),

forAll x : int(1..length) .
  |xPoints[x, 1] - xPoints[x, 2]| > verticalGaps[x],

forAll y : int(1..length) .
  |yPoints[y, 1] - yPoints[y, 2]| > horizontalGaps[y]

$ forAll x : int(1..length) .
$   forAll y : int(1..length) .
$     m[x, y] = 1 <-> (
$       (forAll gap : int(x - horizontalGaps[y]..x + horizontalGaps[y]) .
$         (gap != x /\ gap >= 1 /\ gap <= length) ->
$           m[gap, y] = 0)
$       /\
$       (forAll gap : int(y - verticalGaps[x]..y + verticalGaps[x]) .
$         (gap != y /\ gap >= 1 /\ gap <= length) ->
$           m[x, gap] = 0)
$       /\
$       (x < length ->
$         (y < length ->
$           m[x + 1, y + 1] = 0)
$         /\
$         (y > 1 ->
$           m[x + 1, y - 1] = 0))
$       /\
$       (x > 1 ->
$         (y < length ->
$             m[x - 1, y + 1] = 0)
$           /\
$           (y > 1 ->
$             m[x - 1, y - 1] = 0))
$     )